diff --git a/sugar/chains.py b/sugar/chains.py
index 6977138..ebbb76a 100644
--- a/sugar/chains.py
+++ b/sugar/chains.py
@@ -241,12 +241,12 @@ class AsyncChain(CommonChain):
         return await contract.functions.quoteGasPayment(domain).call()
 
     @require_async_context
-    async def _internal_bridge_token(self, from_token: Token, destination_token: Token, amount_wei: int, domain: int):
+    async def _internal_bridge_token(self, from_token: Token, destination_token: Token, amount: int, domain: int):
         # XX: marking this API as "internal" for now
         # TODO: remove destination_domain when get domain API stabilizes
         c = self.web3.eth.contract(address=self.settings.bridge_contract_addr, abi=bridge_transfer_remote_abi)
-        await self.set_token_allowance(from_token, self.settings.bridge_contract_addr, amount_wei)
-        return await self.sign_and_send_tx(c.functions.transferRemote(domain, to_bytes32(self.account.address), amount_wei), value=await self.get_bridge_fee(domain))
+        await self.set_token_allowance(from_token, self.settings.bridge_contract_addr, amount)
+        return await self.sign_and_send_tx(c.functions.transferRemote(domain, to_bytes32(self.account.address), amount), value=await self.get_bridge_fee(domain))
     
     @require_async_context
     async def get_xchain_fee(self, destination_domain: int) -> int:
@@ -381,20 +381,17 @@ class AsyncChain(CommonChain):
             return self.prepare_quotes(inputs, await batch.async_execute())
 
     @require_async_context
-    async def get_quote(self, from_token: Token, to_token: Token, amount: Optional[float] = None, amount_wei: Optional[int] = None, filter_quotes: Optional[Callable[[Quote], bool]] = None) -> Optional[Quote]:
-        if amount is None and amount_wei is None: raise ValueError("Either amount or amount_wei must be provided")
-        if amount is not None and amount_wei is not None: raise ValueError("Only one of amount or amount_wei should be provided")
-        amount_in = amount_wei or from_token.to_wei(amount)
+    async def get_quote(self, from_token: Token, to_token: Token, amount: int, filter_quotes: Optional[Callable[[Quote], bool]] = None) -> Optional[Quote]:
         pools = self.filter_pools_for_swap(from_token=from_token, to_token=to_token, pools=await self.get_pools_for_swaps())
         paths = self.get_paths_for_quote(from_token, to_token, pools, self.settings.excluded_tokens_addrs)
-        quotes = sum(await asyncio.gather(*[self._get_quotes_for_paths(from_token, to_token, amount_in, pools, paths) for paths in chunk(paths, 500)]), [])
+        quotes = sum(await asyncio.gather(*[self._get_quotes_for_paths(from_token, to_token, amount, pools, paths) for paths in chunk(paths, 500)]), [])
         quotes = list(filter(lambda q: q is not None, quotes))
         if filter_quotes is not None: quotes = list(filter(filter_quotes, quotes))
         return max(quotes, key=lambda q: q.amount_out) if len(quotes) > 0 else None
     
     @require_async_context
-    async def swap(self, from_token: Token, to_token: Token, amount: Optional[float] = None, amount_wei: Optional[int] = None, slippage: Optional[float] = None):
-        q = await self.get_quote(from_token, to_token, amount=amount, amount_wei=amount_wei)
+    async def swap(self, from_token: Token, to_token: Token, amount: int, slippage: Optional[float] = None):
+        q = await self.get_quote(from_token, to_token, amount=amount)
         if not q: raise ValueError("No quotes found")
         return await self.swap_from_quote(q, slippage=slippage)
         
@@ -440,7 +437,7 @@ class AsyncChain(CommonChain):
             pool.token1.token_address,
             pool.is_stable,
             pool.factory,
-            pool.token0.to_wei(amount_token0),
+            amount_token0,
             MAX_UINT256
         ).call()
         print(f"Quote: {pool.token0.symbol} {token0_amount / 10 ** pool.token0.decimals} -> {pool.token1.symbol} {token1_amount / 10 ** pool.token1.decimals}")
@@ -568,12 +565,12 @@ class Chain(CommonChain):
         return contract.functions.quoteGasPayment(domain).call()
     
     @require_context
-    def _internal_bridge_token(self, from_token: Token, destination_token: Token, amount_wei: int, domain: int):
+    def _internal_bridge_token(self, from_token: Token, destination_token: Token, amount: int, domain: int):
         # XX: marking this API as "internal" for now
         # TODO: remove destination_domain when get domain API stabilizes
         c = self.web3.eth.contract(address=self.settings.bridge_contract_addr, abi=bridge_transfer_remote_abi)
-        self.set_token_allowance(from_token, self.settings.bridge_contract_addr, amount_wei)
-        return self.sign_and_send_tx(c.functions.transferRemote(domain, to_bytes32(self.account.address), amount_wei), value=self.get_bridge_fee(domain))
+        self.set_token_allowance(from_token, self.settings.bridge_contract_addr, amount)
+        return self.sign_and_send_tx(c.functions.transferRemote(domain, to_bytes32(self.account.address), amount), value=self.get_bridge_fee(domain))
 
     @require_context
     def get_xchain_fee(self, destination_domain: int) -> int:
@@ -722,16 +719,13 @@ class Chain(CommonChain):
             return self.prepare_quotes(inputs, batch.execute())
     
     @require_context
-    def get_quote(self, from_token: Token, to_token: Token, amount: Optional[float] = None, amount_wei: Optional[int] = None, filter_quotes: Optional[Callable[[Quote], bool]] = None) -> Optional[Quote]:
-        if amount is None and amount_wei is None: raise ValueError("Either amount or amount_wei must be provided")
-        if amount is not None and amount_wei is not None: raise ValueError("Only one of amount or amount_wei should be provided")
-        amount_in = amount_wei or from_token.to_wei(amount)
+    def get_quote(self, from_token: Token, to_token: Token, amount: int, filter_quotes: Optional[Callable[[Quote], bool]] = None) -> Optional[Quote]:
         pools = self.filter_pools_for_swap(from_token=from_token, to_token=to_token, pools=self.get_pools_for_swaps())
         paths = self.get_paths_for_quote(from_token, to_token, pools, self.settings.excluded_tokens_addrs)
         path_chunks = list(chunk(paths, 500))
 
         def get_quotes_for_chunk(paths_chunk):
-            return self._get_quotes_for_paths(from_token, to_token, amount_in, pools, paths_chunk)
+            return self._get_quotes_for_paths(from_token, to_token, amount, pools, paths_chunk)
         
         all_quotes = []
         
@@ -758,8 +752,8 @@ class Chain(CommonChain):
         return max(all_quotes, key=lambda q: q.amount_out) if len(all_quotes) > 0 else None
     
     @require_context
-    def swap(self, from_token: Token, to_token: Token, amount: Optional[float] = None, amount_wei: Optional[int] = None, slippage: Optional[float] = None):
-        q = self.get_quote(from_token, to_token, amount=amount, amount_wei=amount_wei)
+    def swap(self, from_token: Token, to_token: Token, amount: int, slippage: Optional[float] = None):
+        q = self.get_quote(from_token, to_token, amount=amount)
         if not q: raise ValueError("No quotes found")
         return self.swap_from_quote(q, slippage=slippage)
         
diff --git a/sugar/deposit.py b/sugar/deposit.py
index cf6172b..f96d48e 100644
--- a/sugar/deposit.py
+++ b/sugar/deposit.py
@@ -14,4 +14,4 @@ class Deposit:
     # pool to deposit into
     pool: LiquidityPool
     # amount of token0 for deposit
-    amount_token0: float
+    amount_token0: int
diff --git a/sugar/pool.py b/sugar/pool.py
index fd9a06a..65c7aa8 100644
--- a/sugar/pool.py
+++ b/sugar/pool.py
@@ -29,18 +29,23 @@ class Price:
 @dataclass(frozen=True)
 class Amount:
     token: Token
-    amount: float
+    amount: int
     price: "Price"
 
     @classmethod
-    def build(cls, address: str, amount: float, tokens: Dict[str, Token], prices: Dict[str, "Price"]) -> "Amount":
+    def build(cls, address: str, amount: int, tokens: Dict[str, Token], prices: Dict[str, "Price"]) -> "Amount":
         address = normalize_address(address)
         if address not in tokens or address not in prices: return None
         token = tokens[address]
-        return Amount(token=token, amount=token.value_from_bigint(amount), price=prices[address])
+        return Amount(token=token, amount=amount, price=prices[address])
 
     @property
-    def amount_in_stable(self) -> float: return self.amount * self.price.price
+    def as_float(self) -> float:
+        """Returns the amount converted from wei/kwei/gwei/mwei to float on the token's decimals."""
+        return self.token.to_float(self.amount)
+
+    @property
+    def amount_in_stable(self) -> float: return self.as_float * self.price.price
 
 
 # %% ../src/pool.ipynb 6
@@ -254,9 +259,11 @@ class LiquidityPoolEpoch:
 
     @property
     def total_fees(self) -> float:
+        """Returns the total fees in USD"""
         return sum([fee.amount_in_stable for fee in self.fees]) if self.fees else 0
     @property
     def total_incentives(self) -> float:
+        """Returns the total incentives in USD"""
         return sum([incentive.amount_in_stable for incentive in self.incentives]) if self.incentives else 0
 
     @property
diff --git a/sugar/quote.py b/sugar/quote.py
index ab7a3cd..ab00d41 100644
--- a/sugar/quote.py
+++ b/sugar/quote.py
@@ -91,21 +91,21 @@ class SuperswapQuote:
         return self.destination_quote.amount_out if self.destination_quote else self.bridged_amount
 
     @staticmethod
-    def bridge_quote(from_token: Token, to_token: Token, amount_in_wei: int) -> 'SuperswapQuote':
-        return SuperswapQuote(from_token=from_token, to_token=to_token, from_bridge_token=from_token, to_bridge_token=to_token, amount_in=amount_in_wei)
+    def bridge_quote(from_token: Token, to_token: Token, amount: int) -> 'SuperswapQuote':
+        return SuperswapQuote(from_token=from_token, to_token=to_token, from_bridge_token=from_token, to_bridge_token=to_token, amount_in=amount)
 
     @staticmethod
-    def calc_bridged_amount(from_token: Token, from_bridge_token: Token, amount_in_wei: int, origin_quote: Optional[Quote] = None) -> int:
+    def calc_bridged_amount(from_token: Token, from_bridge_token: Token, amount: int, origin_quote: Optional[Quote] = None) -> int:
         if from_token != from_bridge_token:
             assert origin_quote is not None, "origin_quote must be set"
             return origin_quote.amount_out
-        else: return amount_in_wei
+        else: return amount
 
     @property
     def bridged_amount(self) -> int: 
         return SuperswapQuote.calc_bridged_amount(
             from_token=self.from_token,
-            from_bridge_token=self.from_bridge_token, amount_in_wei=self.amount_in, origin_quote=self.origin_quote
+            from_bridge_token=self.from_bridge_token, amount=self.amount_in, origin_quote=self.origin_quote
         )
 
     @property
diff --git a/sugar/superswap.py b/sugar/superswap.py
index 9ac6441..819f5db 100644
--- a/sugar/superswap.py
+++ b/sugar/superswap.py
@@ -200,7 +200,7 @@ class Superswap(SuperswapCommon):
             tx = chain._internal_bridge_token(from_token, to_token, amount, get_domain(int(to_token.chain_id)))
             return f'0x{tx["transactionHash"].hex()}'
 
-    def swap(self, from_token: Token, to_token: Token, amount: float, slippage: Optional[float] = None) -> str:
+    def swap(self, from_token: Token, to_token: Token, amount: int, slippage: Optional[float] = None) -> str:
         self.check_chain_support(from_token, to_token)
         quote = self.get_super_quote(from_token=from_token, to_token=to_token, amount=amount)
 
@@ -208,29 +208,29 @@ class Superswap(SuperswapCommon):
 
         return self.swap_from_quote(quote=quote, slippage=slippage)
 
-    def get_super_quote(self, from_token: Token, to_token: Token, amount: float) -> Optional[SuperswapQuote]:
-        q, amount_in_wei = None, from_token.to_wei(amount)
+    def get_super_quote(self, from_token: Token, to_token: Token, amount: int) -> Optional[SuperswapQuote]:
+        q = None
         with get_chain_from_token(from_token) as from_chain, get_chain_from_token(to_token) as to_chain:
             from_bridge_token, to_bridge_token = from_chain.get_bridge_token(), to_chain.get_bridge_token()
 
             # are we bridging?
             if from_token == from_bridge_token and to_token == to_bridge_token:
-                q = SuperswapQuote.bridge_quote(from_token=from_token, to_token=to_token, amount_in_wei=amount_in_wei)       
+                q = SuperswapQuote.bridge_quote(from_token=from_token, to_token=to_token, amount=amount)       
             else:
                 o_q, d_q = None, None
                 # we only need origin quote if we don't start with bridge token
                 if from_token != from_bridge_token:
-                    o_q = from_chain.get_quote(from_token, from_bridge_token, amount_wei=amount_in_wei)
+                    o_q = from_chain.get_quote(from_token, from_bridge_token, amount=amount)
                     if o_q is None: return None
 
                 # we need destination quote if we don't end with oUSDT
                 if to_token != to_bridge_token:
-                    b_a = SuperswapQuote.calc_bridged_amount(from_token, from_bridge_token, amount_in_wei, o_q)
-                    d_q = to_chain.get_quote(to_bridge_token, to_token, amount_wei=b_a)
+                    b_a = SuperswapQuote.calc_bridged_amount(from_token, from_bridge_token, amount, o_q)
+                    d_q = to_chain.get_quote(to_bridge_token, to_token, amount=b_a)
                     if d_q is None: return None
 
                 q = SuperswapQuote(from_token=from_token,to_token=to_token, from_bridge_token=from_bridge_token, to_bridge_token=to_bridge_token,
-                    amount_in=amount_in_wei, origin_quote=o_q, destination_quote=d_q)
+                    amount_in=amount, origin_quote=o_q, destination_quote=d_q)
         return q
 
     def swap_from_quote(self, quote: SuperswapQuote, slippage: Optional[float] = None, salt: Optional[str] = None):
@@ -289,7 +289,7 @@ class AsyncSuperswap(SuperswapCommon):
             tx = await chain._internal_bridge_token(from_token, to_token, amount, await get_domain_async(int(to_token.chain_id)))
             return f'0x{tx["transactionHash"].hex()}'
 
-    async def swap(self, from_token: Token, to_token: Token, amount: float, slippage: Optional[float] = None) -> str:
+    async def swap(self, from_token: Token, to_token: Token, amount: int, slippage: Optional[float] = None) -> str:
         self.check_chain_support(from_token, to_token)
         quote = await self.get_super_quote(from_token=from_token, to_token=to_token, amount=amount)
 
@@ -297,29 +297,29 @@ class AsyncSuperswap(SuperswapCommon):
 
         return await self.swap_from_quote(quote=quote, slippage=slippage)
 
-    async def get_super_quote(self, from_token: Token, to_token: Token, amount: float) -> Optional[SuperswapQuote]:
-        q, amount_in_wei = None, from_token.to_wei(amount)
+    async def get_super_quote(self, from_token: Token, to_token: Token, amount: int) -> Optional[SuperswapQuote]:
+        q = None
         async with get_async_chain_from_token(from_token) as from_chain, get_async_chain_from_token(to_token) as to_chain:
             from_bridge_token, to_bridge_token = await from_chain.get_bridge_token(), await to_chain.get_bridge_token()
 
             # are we bridging?
             if from_token == from_bridge_token and to_token == to_bridge_token:
-                q = SuperswapQuote.bridge_quote(from_token=from_token, to_token=to_token, amount_in_wei=amount_in_wei)
+                q = SuperswapQuote.bridge_quote(from_token=from_token, to_token=to_token, amount=amount)
             else:
                 o_q, d_q = None, None
                 # we only need origin quote if we don't start with bridge token
                 if from_token != from_bridge_token:
-                    o_q = await from_chain.get_quote(from_token, from_bridge_token, amount_wei=amount_in_wei)
+                    o_q = await from_chain.get_quote(from_token, from_bridge_token, amount=amount)
                     if o_q is None: return None
 
                 # we need destination quote if we don't end with bridge token
                 if to_token != to_bridge_token:
-                    b_a = SuperswapQuote.calc_bridged_amount(from_token, from_bridge_token, amount_in_wei, o_q)
-                    d_q = await to_chain.get_quote(to_bridge_token, to_token, amount_wei=b_a)
+                    b_a = SuperswapQuote.calc_bridged_amount(from_token, from_bridge_token, amount, o_q)
+                    d_q = await to_chain.get_quote(to_bridge_token, to_token, amount=b_a)
                     if d_q is None: return None
 
                 q = SuperswapQuote(from_token=from_token, to_token=to_token, from_bridge_token=from_bridge_token, to_bridge_token=to_bridge_token,
-                    amount_in=amount_in_wei, origin_quote=o_q, destination_quote=d_q)
+                    amount_in=amount, origin_quote=o_q, destination_quote=d_q)
 
         return q
 
diff --git a/sugar/token.py b/sugar/token.py
index 7cc6fa4..23b2a13 100644
--- a/sugar/token.py
+++ b/sugar/token.py
@@ -27,12 +27,12 @@ class Token:
         t1, t2 = normalize_address(self.wrapped_token_address or self.token_address), normalize_address(other.wrapped_token_address or other.token_address)
         return  t1 == t2 and self.chain_id == other.chain_id
 
-    def to_wei(self, value: float) -> int:
-        """Convert a value to wei based on the token's decimals."""
+    def parse_units(self, value: float) -> int:
+        """Convert a value to wei/kwei/gwei/mwei based on the token's decimals."""
         return float_to_uint256(value=value, decimals=self.decimals)
 
-    def to_decimal(self, value: int) -> float:
-        """Convert a value from wei to decimal based on the token's decimals."""
+    def to_float(self, value: int) -> float:
+        """Convert a value from wei/kwei/gwei/mwei to decimal based on the token's decimals."""
         return float(value / 10 ** self.decimals)
 
     @property
