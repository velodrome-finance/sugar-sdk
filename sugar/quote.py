# AUTOGENERATED! DO NOT EDIT! File to edit: ../src/quote.ipynb.

# %% auto 0
__all__ = ['QUOTER_STABLE_POOL_FILLER', 'QUOTER_VOLATILE_POOL_FILLER', 'Quote', 'PreparedRoute', 'RouteInput', 'prepare_route']

# %% ../src/quote.ipynb 3
from functools import reduce
from typing import List, Union
from eth_abi.packed import encode_packed
from dataclasses import dataclass
from .token import Token
from .pool import LiquidityPoolForSwap

# %% ../src/quote.ipynb 4
@dataclass
class Quote:
    from_token: Token; to_token: Token; path: List[LiquidityPoolForSwap]; amount_in: int; amount_out: int

    def to_tuple(self) -> tuple: return (self.from_token, self.to_token, tuple(self.path), self.amount_in, self.amount_out)

    @staticmethod
    def from_tuple(t: tuple) -> "Quote":
        from_token, to_token, path, amount_in, amount_out = t
        return Quote(from_token=from_token, to_token=to_token, path=list(path), amount_in=amount_in, amount_out=amount_out)

# magic numbers
QUOTER_STABLE_POOL_FILLER, QUOTER_VOLATILE_POOL_FILLER = 2097152, 4194304

@dataclass
class PreparedRoute:
    types: List[str]; values: List[Union[str, int]]

    @property
    def encoded(self) -> bytes: return encode_packed(self.types, self.values)

@dataclass
class RouteInput: pool: LiquidityPoolForSwap; reversed: bool

def prepare_route(nodes: List[RouteInput]) -> PreparedRoute:
    types, values = reduce(lambda s, pool: s + pool, [["address", "int24"] for i in range(len(nodes))], []) + ["address"], []
    for node in nodes:
        pool, reversed = node.pool, node.reversed
        token0, token1 = pool.token0 if not reversed else pool.token1, pool.token1 if not reversed else pool.token0
        if pool.type > 0: filler = pool.type
        else: filler =  QUOTER_STABLE_POOL_FILLER if pool.is_stable else QUOTER_VOLATILE_POOL_FILLER
        if len(values) == 0: values = [token0.token_address, filler, token1.token_address]
        else: values += [filler, token1.token_address]
    return PreparedRoute(types=types, values=values)
